# 变量提升
## 结论

- `let` 的「创建」过程被提升了，但是初始化没有提升。
- `var` 的「创建」和「初始化」都被提升了。
- `function` 的「创建」「初始化」和「赋值」都被提升了。

## let和const
let和const采用暂时死区的策略
### 暂时死区（也就是承认let也会提升）
进入变量作用域与执行声明之间的这段时间被称为该变量的**暂时死区**（TDZ）：

- 在此期间，该变量被认为是未初始化的（就好像它有一个特殊的值）。
- 如果你访问一个未初始化的变量，你会得到一个 `ReferenceError`。
- 一旦你执行到了变量声明，这个变量将被设置为初始化的值（通过赋值符号指定）或者 `undefined` —— 如果没有初始化的话。
## 函数
函数声明采取**暂时死区**和**提前激活**的策略。

- 函数会提升到当前作用域的最开始并且对其完整赋值之后再执行代码， 其中：如果函数中引用了其他未定义的函数、变量，是无妨的，比如：
```js
function fun1(){
  console.log(nofun);
}
function fun2(){
  let a = novariable;
}
```
这两个都不会报错，与之相对的,很容易混淆的是
```js
var obj = {
  key:value//value没有被定义过
}
```
结果是报错，那么为什么呢，其实是普通变量在创建时的赋值是会在当前作用域的执行阶段进行的，而定义一个函数时函数里面的代码是在这个函数被调用时才会被执行：

一个函数内部的代码在创建这个函数的时候并不会被检查其中使用的变量的存在与否，只会检查一下语法错误（见下）
```js
function fun3(){asd asd}//里面是乱写的就会报错
```
